% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_freqs.R
\name{get_freqs}
\alias{get_freqs}
\title{Compute weighted frequencies, optionally grouped and/or across multiple variables}
\usage{
get_freqs(
  data,
  x,
  group,
  wt,
  names_to = "names",
  values_to = "values",
  name_label = NULL,
  keep,
  drop_zero = FALSE,
  decimals = 3,
  na.rm = TRUE
)
}
\arguments{
\item{data}{A data frame/tibble, \code{survey.design}, or \code{svyrep.design} object.}

\item{x}{<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> Columns selecting one or more
variables. You can pass:
\itemize{
\item A bare column name (e.g., \code{x = q1})
\item A tidyselect expression (e.g., \code{x = tidyselect::starts_with("q")})
\item A vector of strings or symbols \code{c("q1", "q2")} or \code{c(q1, q2)}.
\item An object containing a vector \code{tidyselect::all_of(variables)}.
}}

\item{group}{<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> A selection of columns
to group the data. This operates very similarly to \code{.by} from dplyr
(for more info on that see \link[dplyr:dplyr_by]{?dplyr_by}). It can also be a
character vector. If using an external character vector it must be
wrapped in curly brackets (\code{{{}}}).

In addition, grouped data can be piped in via \code{dplyr::group_by()} or
\code{srvyr::group_by()}. If data is a \code{grouped_df} and \code{group} is provided,
\code{get_means()} will combine the variable(s) used in either \code{group_by}
function and the variable(s) supplied in \code{group} to calculate
frequencies.}

\item{wt}{Optional weight column (numeric). Ignored for \code{survey.design}
or \code{svyrep.design} inputs, where weights come from the design. If omitted
for data frames, will output unweighted frequencies.}

\item{names_to}{A character vector specifying the new column or columns to
create from the information stored in the column names of \code{data} specified
by \code{cols}.  Default is \code{"values"}.
\itemize{
\item If length 0, or if \code{NULL} is supplied, no columns will be created.
\item If length 1, a single column will be created which will contain the
column names specified by \code{cols}.
\item If length >1, multiple columns will be created. In this case, one of
\code{names_sep} or \code{names_pattern} must be supplied to specify how the
column names should be split. There are also two additional character
values you can take advantage of:
\itemize{
\item \code{NA} will discard the corresponding component of the column name.
\item \code{".value"} indicates that the corresponding component of the column
name defines the name of the output column containing the cell values,
overriding \code{values_to} entirely.
}
}}

\item{values_to}{A string specifying the name of the column to create
from the data stored in cell values. If \code{names_to} is a character
containing the special \code{.value} sentinel, this value will be ignored,
and the name of the value column will be derived from part of the
existing column names. Default is \code{"values"}}

\item{name_label}{Optional label to attach to the \code{names_to} column in
multi-variable outputs (e.g., a question preface). If missing, will check
the data for a \code{question_preface} attribute.}

\item{keep}{Optional post-aggregation filter applied only to multi-variable outputs:
\itemize{
\item character vector: keep only rows where \code{values_to} is in this set
\item function: predicate on the \code{values_to} vector; returns logical mask (length
\code{nrow} or scalar \code{TRUE})
\item tidy expression: a dplyr-style filter expression evaluated in the result
context
}}

\item{drop_zero}{Logical; whether to drop zero-count rows from the output.
\itemize{
\item Default path (data.frame): combined with \code{dplyr::count(.drop = drop_zero)} to
control inclusion of zero levels.
\item Survey path (\code{survey.design}):
\itemize{
\item Single-variable: zero-count response levels can be included when
\code{drop_zero = FALSE}.
\item Multi-variable: zero-count levels are not kept at this time.
}
}}

\item{decimals}{Number of decimal places for rounding counts (\code{n}). Percent
(\code{pct}) is rounded to \code{decimals + 2} so that it contains the right number
of decimals when multiplying by 100.}

\item{na.rm}{Logical; whether to remove rows with missing values in \code{x} and \code{group}
before computing frequencies. Default is \code{TRUE}.}
}
\value{
A tibble with columns:
\itemize{
\item For single-variable inputs: \verb{[x variable]}, \code{n}, \code{pct}, and any grouping
columns.
\item For multi-variable inputs: \verb{[grouping columns if any]}, \verb{[names_to]},
\verb{[values_to]}, \code{n}, \code{pct}.
}

The result has class \code{"tidysurvey_freqs"} and common attributes:
\itemize{
\item \code{attr(., "dataset")}: the original dataset
\item \code{attr(., "variable_label")}, \code{attr(., "variable_name")}
\item For grouped outputs: \code{attr(., "group_names")} and \code{attr(., "group_labels")}
\item For multi-variable: \code{attr(., "item_names")}, \code{attr(., "item_labels")},
\code{attr(., "x_expr")}
}
}
\description{
\code{get_freqs()} computes weighted frequency tables for survey-style data. It
supports:
\itemize{
\item Plain data frames with an optional weight column
\item \code{survey.design} and \code{svyrep.design} objects (from the survey/srvyr ecosystem)
\item Single-variable or multi-variable inputs
\item Optional grouping variables
\item Optional inclusion/exclusion of zero-count levels (see Limitations for
survey multi-variable)
}

For single-variable inputs, the response column in the output retains the
original variable name. For multi-variable inputs, responses are pivoted to
long format using \code{names_to} and \code{values_to}.
}
\details{
The \code{keep} argument is applied after aggregation in multi-variable outputs to filter
rows of the result based on the response column (\code{values_to}). It is ignored for
single-variable calls. Accepted forms:
\itemize{
\item Character vector: \code{keep = c("yes", "no")}
\item Function: \verb{keep = \\(v) v \%in\% c("yes", "no")} or any predicate that returns a
logical vector of length \code{nrow(result)} or a single \code{TRUE} (no filtering). \code{NA}
entries are dropped.
\item Tidy expression: \code{keep = .data[[values_to]] \%in\% c("yes","no")} or simply
\code{resp != "skip"} when \code{values_to = "resp"}.
}

Note: For tidy expressions, the expression is evaluated in the context of the
result tibble.
}
\section{Methods}{

\itemize{
\item \code{get_freqs.default()}: Operates on data frames/tibbles. If \code{wt} is omitted,
simple unweighted frequencies are reported. Calculation is from \code{dplyr::count()}
with \code{.drop = drop_zero}; zero-count levels can be included when
\code{drop_zero = FALSE} and the variables are factors with unused levels.
\item \code{get_freqs.survey.design()}: Operates on \code{survey.design} objects. Weights are taken from
the design. Grouping is honored inside low-level survey computations.
\item \code{get_freqs.svyrep.design()}: Operates on \code{svyrep.design} objects.
}
}

\section{Limitations (survey.design with multiple variables)}{

For multi-variable \code{survey.design} inputs (\code{x} selects multiple variables), zero-count response
levels are not currently expanded. Results include only observed levels per item, regardless of
\code{drop_zero}. This differs from the default (non-survey) path. For single-variable
\code{survey.design} inputs, zero-count levels can be included when \code{drop_zero = FALSE}.
}

\examples{
# here's a basic unweighted frequency for satisfaction_service
get_freqs(df, x = satisfaction_service)

# now check it with weights
get_freqs(df, x = satisfaction_service, wt = wts)

# now check grouped
get_freqs(df, x = satisfaction_service, group = grp, wt = wts)

# groups can also be added by using `group_by()` ahead of time
df |>
  dplyr::group_by() |>
  get_freqs(df, x = satisfaction_service, wt = wts)

# Now check with multiple x variables
get_freqs(
  df,
  x = c("x1", "x2"),
  wt = wts,
  na.rm = TRUE
)

# rename the outputs
get_freqs(
  df,
  x = c("x1", "x2"),
  wt = wts,
  names_to = "item",
  values_to = "resp",
  na.rm = TRUE
)

# now check multiple x variables with a grouping variable
get_freqs(
  df,
  x = c("x1", "x2"),
  group = "grp",
  wt = wts,
  na.rm = TRUE
)

# ---- keep examples (multi-variable, data frame) ----

# 1) keep as a character vector: retain only "yes" responses across items
get_freqs(
  df,
  x = c("x1", "x2"),
  wt = wts,
  keep = c("yes"),
  na.rm = TRUE
)

# Survey design  ------------
\dontshow{if (requireNamespace("srvyr", quietly = TRUE)) withAutoprint(\{ # examplesIf}
df_svy <- srvyr::as_survey_design(
   ids = id,
   strata = strata,
   weights = "wts",
   .data = _
 )

# basic example
get_freqs(df_svy, x = satisfaction_service)

# multi-variable example
get_freqs(df_svy, c(x1, x2))

# grouped example
get_freqs(df_svy, satisfaction_service, grp)

# grouped example with multi-variable
get_freqs(df_svy, c(x1, x2), grp)

\dontshow{\}) # examplesIf}
}
\seealso{
\itemize{
\item \code{\link[survey:svydesign]{survey::svydesign()}}, \code{\link[srvyr:as_survey]{srvyr::as_survey()}}
\item \code{\link[dplyr:count]{dplyr::count()}}, \code{\link[tidyr:pivot_longer]{tidyr::pivot_longer()}}
}
}
